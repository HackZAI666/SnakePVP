<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>贪吃蛇 — HackZ 出品</title>
  <style>
    :root{--bg:#0f1724;--panel:#0b1220;--accent1:#7c3aed;--accent2:#06b6d4;}
    html,body{height:100%;margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,'Helvetica Neue',Arial;background:linear-gradient(180deg,var(--bg),#020617);color:#e6eef8}
    /* splash */
    .splash{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;flex-direction:column;z-index:40;background:linear-gradient(135deg,var(--accent1),var(--accent2));color:white}
    .splash .logo{font-size:clamp(32px,7vw,88px);font-weight:900;letter-spacing:4px;opacity:0;transform:translateY(28px);animation:logoIn 1.1s ease forwards}
    .splash .sub{margin-top:10px;font-size:15px;opacity:0;color:rgba(255,255,255,0.95);animation:subIn 1s 0.9s ease forwards}
    @keyframes logoIn{to{opacity:1;transform:translateY(0)}}
    @keyframes subIn{to{opacity:1;transform:translateY(0)}}

    /* main menu */
    .menu{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;z-index:30}
    .panel{background:rgba(6,10,16,0.65);backdrop-filter:blur(6px);padding:20px;border-radius:12px;box-shadow:0 6px 30px rgba(2,6,23,0.6);width:min(1200px,94%);display:grid;grid-template-columns:1fr 420px;gap:18px}
    .left{padding:12px}
    .title{font-size:22px;margin:0 0 8px 0}
    .desc{font-size:14px;color:#c9d7ea;margin-bottom:12px}
    .controls{display:flex;gap:8px;flex-wrap:wrap}
    .btn{background:linear-gradient(90deg,rgba(255,255,255,0.03),rgba(255,255,255,0.01));border:1px solid rgba(255,255,255,0.06);padding:10px 14px;border-radius:8px;color:white;cursor:pointer}
    .btn.primary{background:linear-gradient(90deg,var(--accent1),var(--accent2));border:none}
    .right{display:flex;flex-direction:column;gap:8px;padding:12px}
    .scoreboard{background:rgba(255,255,255,0.03);padding:12px;border-radius:8px;color:#cfe7ff}

    /* game area */
    .game-wrap{display:flex;align-items:center;justify-content:center;flex-direction:column;padding:18px;position:relative}
    canvas{background:linear-gradient(180deg,#00111a,#041227);border-radius:10px;box-shadow:0 8px 26px rgba(2,6,23,0.6);max-width:100%;height:auto}
    .hud{display:flex;gap:8px;align-items:center;margin-top:12px;flex-wrap:wrap}
    .small{font-size:13px;color:#cfe7ff}

    /* touch controls */
    .touch-controls{position:absolute;right:18px;bottom:18px;display:grid;grid-template-columns:56px 56px;grid-template-rows:56px 56px;gap:8px;z-index:50}
    .touch-controls button{width:56px;height:56px;border-radius:8px;border:none;background:rgba(255,255,255,0.06);color:white;font-size:18px}
    .touch-controls .up{grid-column:1/3;grid-row:1/2;justify-self:center}
    .touch-controls .left{grid-column:1/2;grid-row:2/3}
    .touch-controls .right{grid-column:2/3;grid-row:2/3}

    /* footer */
    .footer{position:fixed;left:12px;bottom:12px;font-size:12px;color:rgba(255,255,255,0.6)}

    /* responsive */
    @media (max-width:1000px){.panel{grid-template-columns:1fr;}.touch-controls{right:12px;bottom:12px}}

    /* help box */
    .help{font-size:13px;color:#bcd9ff;background:rgba(255,255,255,0.02);padding:10px;border-radius:8px}
  </style>
</head>
<body>

  <!-- Splash：HackZ 出品（颜色不变，时长稍长） -->
  <div id="splash" class="splash" aria-hidden="false">
    <div class="logo">HackZ 出品</div>
    <div class="sub">贪吃蛇 — 单人 / 双人 / 人机 / 手机 模式 即刻开战</div>
  </div>

  <!-- 主菜单 -->
  <div id="menu" class="menu" style="display:none">
    <div class="panel">
      <div class="left">
        <h2 class="title">贪吃蛇 — HackZ 出品</h2>
        <div class="desc">选择模式并开始游戏。单人模式含苹果（食物）；双人模式为本地对战（玩家1：WASD，玩家2：方向键），双人模式无苹果。新增 人机模式 与 手机模式（带触控按键）。</div>

        <div style="display:flex;gap:8px;margin-bottom:10px;flex-wrap:wrap">
          <button id="singleBtn" class="btn primary">单人游戏</button>
          <button id="twoBtn" class="btn">双人对战</button>
          <button id="aiBtn" class="btn">人机模式</button>
          <button id="mobileBtn" class="btn">手机模式</button>
          <button id="practiceBtn" class="btn">练习（无常规碰撞）</button>
        </div>

        <div class="help">速度：<input id="speedRange" type="range" min="4" max="20" value="10"> <span id="speedVal">10</span></div>
        <div style="height:12px"></div>
        <div class="help">格子大小：<select id="tileSize">
          <option value="12">12 px</option>
          <option value="16">16 px</option>
          <option value="20" selected>20 px</option>
          <option value="24">24 px</option>
        </select></div>

        <div style="height:14px"></div>
        <div class="help">操控：<br>玩家1: W/A/S/D &nbsp; 玩家2: 方向键（或使用手机模式按键）</div>
      </div>

      <div class="right">
        <div class="scoreboard"><strong>当前分数</strong>
          <div id="scoreDisplay">—</div>
        </div>
        <div class="scoreboard"><strong>玩法提示</strong>
          <ul style="margin:6px 0 0 18px;padding:0">
            <li>尽量不要急转弯，提前规划行进路线。</li>
            <li>双人模式下，玩家2的身体触碰到玩家1的头部时，玩家1将失败。</li>
            <li>界内的红色矩形为致命边界，触碰即死（练习模式除外）。红色边界已再放大一些。</li>
          </ul>
        </div>

        <div style="flex:1"></div>
        <div style="font-size:12px;color:#9fbff0">静态页面：把此文件命名为 <code>index.html</code> 并上传到 GitHub 仓库，启用 GitHub Pages 即可。</div>
      </div>
    </div>
  </div>

  <!-- 游戏区域 -->
  <div id="game" class="game-wrap" style="display:none">
    <canvas id="c"></canvas>

    <!-- 手机触摸按键（仅在手机模式显示） -->
    <div id="touchControls" class="touch-controls" style="display:none;">
      <button id="btnUp" class="up">↑</button>
      <button id="btnLeft" class="left">←</button>
      <button id="btnRight" class="right">→</button>
      <button id="btnDown" class="down">↓</button>
    </div>

    <div class="hud">
      <div class="small">模式：<span id="modeLabel">—</span></div>
      <div class="small">分数：<span id="score">0</span></div>
      <div class="small">P1：WASD</div>
      <div class="small">P2：方向键 / AI / 手机按键</div>
      <button id="pauseBtn" class="btn" style="margin-left:8px">暂停</button>
      <button id="restartBtn" class="btn">重开</button>
    </div>
  </div>

  <div class="footer">HackZ 出品 · 静态 GitHub Pages 演示</div>

  <script>
    // —— 基本设置（做了响应式 canvas，默认更大）
    const splash = document.getElementById('splash');
    const menu = document.getElementById('menu');
    const gameWrap = document.getElementById('game');
    const c = document.getElementById('c');
    const ctx = c.getContext('2d');
    const scoreEl = document.getElementById('score');
    const scoreDisplay = document.getElementById('scoreDisplay');
    const modeLabel = document.getElementById('modeLabel');
    const speedRange = document.getElementById('speedRange');
    const speedVal = document.getElementById('speedVal');
    const tileSizeSel = document.getElementById('tileSize');
    const pauseBtn = document.getElementById('pauseBtn');
    const restartBtn = document.getElementById('restartBtn');
    const touchControls = document.getElementById('touchControls');
    const btnUp = document.getElementById('btnUp');
    const btnDown = document.getElementById('btnDown');
    const btnLeft = document.getElementById('btnLeft');
    const btnRight = document.getElementById('btnRight');

    let tile = parseInt(tileSizeSel.value);
    let cols = 0;
    let rows = 0;
    let gameInterval = null;
    let tickMs = 1000 / parseInt(speedRange.value);
    let paused = false;
    // 红色致命边界边距（以格子数计）；设为 2（比之前稍大）
    let defaultBoundaryMargin = 2;
    let boundaryMarginTiles = defaultBoundaryMargin;

    // 调整 splash 时长（稍微长一点）：显示时间 -> 2200ms，淡出 900ms
    setTimeout(()=>{
      splash.style.transition = 'opacity 0.9s';
      splash.style.opacity = 0;
      setTimeout(()=>{splash.style.display='none'; menu.style.display='flex'},900);
    },2200);

    // 响应式 canvas：初始和 resize 调整到更大尺寸（占窗口的一部分），并重计算格子数
    function resizeCanvas(){
      // 限制最大尺寸以防过大
      const maxW = Math.min(Math.floor(window.innerWidth * 0.94), 1400);
      const maxH = Math.min(Math.floor(window.innerHeight * 0.82), 920);
      // 保持宽高比约 4:3
      let w = maxW; let h = Math.floor(w * 3/4);
      if(h > maxH){ h = maxH; w = Math.floor(h * 4/3); }
      c.width = w; c.height = h;
      // 重新计算格子数量
      tile = parseInt(tileSizeSel.value);
      cols = Math.floor(c.width / tile);
      rows = Math.floor(c.height / tile);
      // boundaryMarginTiles 保持 defaultBoundaryMargin，但不超过网格的一半
      boundaryMarginTiles = Math.max(1, Math.min(defaultBoundaryMargin, Math.floor(Math.min(cols,rows)/2)));
    }
    window.addEventListener('resize', ()=>{ const wasVisible = (gameWrap.style.display!=='none'); resizeCanvas(); if(wasVisible) initGame(mode); else render(); });

    speedRange.addEventListener('input', ()=>{speedVal.textContent = speedRange.value; tickMs = 1000/parseInt(speedRange.value); if(gameInterval) startLoop();});
    tileSizeSel.addEventListener('change', ()=>{ tile = parseInt(tileSizeSel.value); cols = Math.floor(c.width / tile); rows = Math.floor(c.height / tile); if(gameInterval) initGame(mode); else render(); });

    // 初始化 canvas 尺寸
    resizeCanvas();

    // 游戏状态
    const State = {SINGLE: 'single', TWO: 'two', AI: 'ai', MOBILE: 'mobile', PRACTICE: 'practice'};
    let mode = null;

    // --- 游戏数据结构 ---
    function makeSnake(x,y,dir,clr,opts={}){
      return {body:[{x,y}],dir:dir,queued:null,color:clr,alive:true,score:0,grow:0,ai:opts.ai||false,aiTimer:0}
    }

    let snakes = [];
    let food = null; // 仅单人/手机模式生成

    function randPos(){
      return {x: Math.floor(Math.random()*cols), y: Math.floor(Math.random()*rows)}
    }

    function spawnFood(){
      if(mode !== State.SINGLE && mode !== State.MOBILE){ food = null; return; } // 只有单人/手机模式有苹果
      for(let i=0;i<1000;i++){
        const p = randPos();
        if(!snakes.some(s=>s.body.some(b=>b.x===p.x && b.y===p.y))){
          // 保证苹果不会出现在红色边界内
          if(p.x < boundaryMarginTiles || p.x >= cols-boundaryMarginTiles || p.y < boundaryMarginTiles || p.y >= rows-boundaryMarginTiles) continue;
          food=p;return}
      }
      food = {x:Math.max(boundaryMarginTiles,1),y:Math.max(boundaryMarginTiles,1)};
    }

    function initGame(m){
      mode = m; modeLabel.textContent = (m===State.SINGLE? '单人' : m===State.TWO? '双人' : m===State.AI? '人机' : m===State.MOBILE? '手机' : '练习');
      // 控制触摸按键的显示
      touchControls.style.display = (mode===State.MOBILE)? 'grid' : 'none';

      // 保证 cols/rows 已准备
      tile = parseInt(tileSizeSel.value); cols = Math.floor(c.width / tile); rows = Math.floor(c.height / tile);
      snakes = [];
      // 玩家1 初始位置左侧偏中（根据当前格子数设置合适位置）
      snakes.push(makeSnake(Math.max(boundaryMarginTiles+2, Math.floor(cols*0.2)), Math.floor(rows/2), 'right','#7c3aed'));
      if(m===State.TWO) snakes.push(makeSnake(Math.min(cols-boundaryMarginTiles-3, Math.floor(cols*0.8)), Math.floor(rows/2), 'left','#06b6d4'));
      if(m===State.AI) snakes.push(makeSnake(Math.min(cols-boundaryMarginTiles-3, Math.floor(cols*0.8)), Math.floor(rows/2), 'left','#06b6d4',{ai:true}));
      if(m===State.MOBILE){
        // 手机模式：单人对抗 AI
        snakes.push(makeSnake(Math.min(cols-boundaryMarginTiles-3, Math.floor(cols*0.8)), Math.floor(rows/2), 'left','#06b6d4',{ai:true}));
      }

      // 给予初始长度
      snakes.forEach((s,i)=>{
        s.alive=true; s.score=0; s.grow = 3; s.body = [];
        // 给每人一个小长度的初始身体，朝向相反
        if(i===0){ // P1
          const startX = Math.max(boundaryMarginTiles+2, Math.floor(cols*0.2));
          for(let k=0;k<4;k++) s.body.push({x:startX - (3-k), y: Math.floor(rows/2)});
          s.dir = 'right';
        } else {
          const startX = Math.min(cols-boundaryMarginTiles-3, Math.floor(cols*0.8));
          for(let k=0;k<4;k++) s.body.push({x:startX + (3-k), y: Math.floor(rows/2)});
          s.dir = 'left';
        }
        s.aiTimer = Math.floor(Math.random()*6) + 2; // AI 改变方向的计时器初始值
      });

      spawnFood();
      scoreEl.textContent = '0';
      scoreDisplay.innerHTML = snakes.map((s,i)=>`P${i+1}: ${s.score}`).join('<br>');
      paused=false; pauseBtn.textContent='暂停';
      startLoop();
    }

    function startLoop(){
      if(gameInterval) clearInterval(gameInterval);
      gameInterval = setInterval(tick, tickMs);
    }

    function stopLoop(){ if(gameInterval) clearInterval(gameInterval); gameInterval=null }

    // 控制输入处理：防止180度急转
    const keyDir = {ArrowUp:'up',ArrowDown:'down',ArrowLeft:'left',ArrowRight:'right',KeyW:'up',KeyS:'down',KeyA:'left',KeyD:'right'};
    window.addEventListener('keydown', (e)=>{
      const k = e.code;
      if(k in keyDir){
        // 双人： WASD 控制 player1， arrows 控制 player2（如果非 AI 且不是手机模式）
        if(snakes.length===2 && !snakes[1].ai && mode!==State.MOBILE){
          if(['KeyW','KeyA','KeyS','KeyD'].includes(k)) setDir(0,keyDir[k]);
          else setDir(1,keyDir[k]);
        } else {
          setDir(0,keyDir[k]);
        }
      }
      if(k==='Space'){
        togglePause(); e.preventDefault()
      }
    })

    function setDir(idx,nd){
      const s = snakes[idx]; if(!s || !s.alive) return;
      const opp = {up:'down',down:'up',left:'right',right:'left'};
      if(s.dir === nd) return;
      if(opp[s.dir]===nd) return; // 不允许直接回头
      s.queued = nd;
    }

    function togglePause(){ paused = !paused; if(paused) { stopLoop(); pauseBtn.textContent='继续'} else { startLoop(); pauseBtn.textContent='暂停' }}
    pauseBtn.addEventListener('click', togglePause);
    restartBtn.addEventListener('click', ()=>{initGame(mode)})

    // 触屏按键绑定（手机模式）
    function bindTouchButton(btn, dir){
      const start = (e)=>{ e.preventDefault(); setDir(0,dir); };
      btn.addEventListener('touchstart', start, {passive:false});
      btn.addEventListener('mousedown', start);
    }
    bindTouchButton(btnUp, 'up'); bindTouchButton(btnDown, 'down'); bindTouchButton(btnLeft, 'left'); bindTouchButton(btnRight, 'right');

    // 更聪明的 AI：评估每个候选方向，避免走入致命边界或立即与身体碰撞，并优先选择安全、靠近食物的路线
    function aiThink(s){
      if(!s.ai || !s.alive) return;
      s.aiTimer = (s.aiTimer||0) - 1;
      if(s.aiTimer > 0) return; // 只有计时到才改变方向
      s.aiTimer = Math.floor(Math.random()*4) + 3; // 重置计时器（略快）

      const dirs = ['up','down','left','right'];
      const opp = {up:'down',down:'up',left:'right',right:'left'};
      const head = s.body[s.body.length-1];

      // 评估候选方向
      let best = null; let bestScore = -Infinity;
      for(const d of dirs){
        if(opp[s.dir] === d) continue; // 不允许直接回头
        // 计算下一格
        let nx = head.x + (d==='left'?-1: d==='right'?1:0);
        let ny = head.y + (d==='up'?-1: d==='down'?1:0);
        // 环绕一致性
        if(nx<0) nx = cols-1; if(nx>=cols) nx=0; if(ny<0) ny=rows-1; if(ny>=rows) ny=0;

        // 若下一格在红色致命边界内 -> 极低分
        const inBoundaryZone = (nx < boundaryMarginTiles || nx >= cols - boundaryMarginTiles || ny < boundaryMarginTiles || ny >= rows - boundaryMarginTiles);
        if(inBoundaryZone){ continue; } // 直接舍弃进入致命区的方向

        // 若下一格与任何蛇身体重合 -> 舍弃
        let collides = false;
        for(const other of snakes){
          for(const part of other.body){ if(part.x===nx && part.y===ny){ collides = true; break; } }
          if(collides) break;
        }
        if(collides) continue;

        // 评分：到最近边界的距离越大越好（更安全），若有食物则更靠近食物更好
        const distToLeft = nx - boundaryMarginTiles;
        const distToRight = (cols - boundaryMarginTiles - 1) - nx;
        const distToTop = ny - boundaryMarginTiles;
        const distToBottom = (rows - boundaryMarginTiles -1) - ny;
        const marginDist = Math.min(distToLeft, distToRight, distToTop, distToBottom);
        let score = marginDist * 2; // 安全性权重

        if(food){
          const man = Math.abs(food.x - nx) + Math.abs(food.y - ny);
          score += Math.max(0, 20 - man) * 0.6; // 靠近食物更好
        }

        // 轻微随机化，避免完全确定性
        score += Math.random() * 0.8;

        if(score > bestScore){ bestScore = score; best = d; }
      }

      // 如果没有安全方向（极少见），退回到随机非反向选择，但仍避免立即撞到身体
      if(!best){
        const cand = dirs.filter(d=>opp[s.dir]!==d);
        for(const d of cand){
          let nx = head.x + (d==='left'?-1: d==='right'?1:0);
          let ny = head.y + (d==='up'?-1: d==='down'?1:0);
          if(nx<0) nx = cols-1; if(nx>=cols) nx=0; if(ny<0) ny=rows-1; if(ny>=rows) ny=0;
          let collides = false;
          for(const other of snakes){ for(const part of other.body){ if(part.x===nx && part.y===ny){ collides = true; break; } } if(collides) break; }
          if(!collides){ best = d; break; }
        }
      }

      if(best) s.queued = best;
    }

    // 主循环
    function tick(){
      // AI 思考先于队列应用
      snakes.forEach(s=>{ if(s.ai) aiThink(s); });

      // 每次 tick 先应用 queued dir
      snakes.forEach(s=>{ if(s.queued){ s.dir = s.queued; s.queued = null }});

      // 移动每条蛇
      snakes.forEach(s=>{
        if(!s.alive) return;
        const head = s.body[s.body.length-1];
        let nx = head.x, ny = head.y;
        if(s.dir==='up') ny--;
        if(s.dir==='down') ny++;
        if(s.dir==='left') nx--;
        if(s.dir==='right') nx++;
        // 先做环绕处理，使移动一致（之后判断是否进入红色致命区）
        if(nx<0) nx = cols-1; if(nx>=cols) nx=0; if(ny<0) ny=rows-1; if(ny>=rows) ny=0;
        // 如果进入红色致命边界区域（在边界内的格子），则死亡（练习模式除外）
        if(!(mode===State.PRACTICE) && (nx < boundaryMarginTiles || nx >= cols - boundaryMarginTiles || ny < boundaryMarginTiles || ny >= rows - boundaryMarginTiles)){
          s.alive = false;
          // 仍把头加入以便渲染出最后位置
          s.body.push({x:nx,y:ny});
          if(s.grow>0) s.grow--; else s.body.shift();
          return;
        }
        s.body.push({x:nx,y:ny});
        if(s.grow>0){ s.grow--; } else { s.body.shift(); }
      });

      // 检查食物吃到（仅单人/手机模式）
      if(mode===State.SINGLE || mode===State.MOBILE){
        snakes.forEach(s=>{
          if(!s.alive) return;
          const h = s.body[s.body.length-1];
          if(food && h.x===food.x && h.y===food.y){ s.grow += 4; s.score += 1; spawnFood(); }
        })
      }

      // 碰撞检测：规则含用户要求的专门判定
      // 1) 自身碰撞
      snakes.forEach((s,si)=>{
        if(!s.alive) return;
        const head = s.body[s.body.length-1];
        for(let i=0;i<s.body.length-1;i++){
          if(s.body[i].x===head.x && s.body[i].y===head.y){
            if(mode===State.PRACTICE) { /* 练习无死亡 */ } else { s.alive=false }
          }
        }
      })

      // 2) 不同蛇之间的碰撞
      if(snakes.length>=2){
        const p1 = snakes[0]; const p2 = snakes[1];
        if(p1.alive && p2.alive){
          const head1 = p1.body[p1.body.length-1];
          const head2 = p2.body[p2.body.length-1];
          // 如果双方头部重合 -> 双方都死
          if(head1.x===head2.x && head1.y===head2.y){ p1.alive=false; p2.alive=false; }

          // 如果玩家2的身体（包括头）触碰到玩家1的头，则玩家1失败
          for(let i=0;i<p2.body.length;i++){
            const b = p2.body[i];
            if(b.x===head1.x && b.y===head1.y){ p1.alive=false; break; }
          }

          // 其他常规判定：玩家1的头撞到玩家2身体 -> 玩家1死亡（保留原有逻辑）
          for(let i=0;i<p2.body.length-1;i++){
            const b = p2.body[i];
            if(b.x===head1.x && b.y===head1.y){ p1.alive=false; }
          }
          // 玩家2撞到玩家1身体 -> 玩家2死亡
          for(let i=0;i<p1.body.length-1;i++){
            const b = p1.body[i];
            if(b.x===head2.x && b.y===head2.y){ p2.alive=false; }
          }
        }
      }

      // 更新分数显示
      scoreEl.textContent = snakes.map(s=>s.score).join(' / ');
      scoreDisplay.innerHTML = snakes.map((s,i)=>`P${i+1}: ${s.score} ${s.alive? '': '(死)'}`).join('<br>');

      // 胜负判断（双人/人机/手机）：一方死亡，另一方存活则获胜；若都死则平局
      if(mode===State.TWO || mode===State.AI || mode===State.MOBILE){
        const aliveCount = snakes.filter(s=>s.alive).length;
        if(aliveCount<=1){ stopLoop(); let msg=''; if(aliveCount===1){ msg = '胜利者：' + (snakes.findIndex(s=>s.alive)+1) + '号' } else { msg='平局' };
          setTimeout(()=>{ alert(msg); },20);
        }
      }

      // 单人/手机：若玩家死亡则结束
      if(mode===State.SINGLE || mode===State.MOBILE){ if(!snakes[0].alive){ stopLoop(); setTimeout(()=>{ alert('游戏结束，得分：' + snakes[0].score); },20) }}

      render();
    }

    // 绘制
    function render(){
      // 清空
      ctx.clearRect(0,0,c.width,c.height);
      // 背景渐变格子
      const g = ctx.createLinearGradient(0,0,0,c.height); g.addColorStop(0,'rgba(255,255,255,0.02)'); g.addColorStop(1,'rgba(255,255,255,0.01)');
      ctx.fillStyle = g; ctx.fillRect(0,0,c.width,c.height);

      // 红色内框：放大一些（boundaryMarginTiles = defaultBoundaryMargin）
      ctx.save();
      ctx.lineWidth = 6;
      ctx.strokeStyle = 'rgba(255,60,60,0.98)';
      const insetPx = boundaryMarginTiles * tile;
      ctx.strokeRect(insetPx, insetPx, c.width - insetPx*2, c.height - insetPx*2);
      ctx.restore();

      // 网格线（淡）
      ctx.strokeStyle = 'rgba(255,255,255,0.02)'; ctx.lineWidth = 1;
      for(let x=0;x<=cols;x++){ ctx.beginPath(); ctx.moveTo(x*tile,0); ctx.lineTo(x*tile,c.height); ctx.stroke(); }
      for(let y=0;y<=rows;y++){ ctx.beginPath(); ctx.moveTo(0,y*tile); ctx.lineTo(c.width,y*tile); ctx.stroke(); }

      // 画苹果（单人/手机模式）
      if(food){
        const cx = food.x*tile + tile/2; const cy = food.y*tile + tile/2;
        // 红色主体
        ctx.beginPath(); ctx.fillStyle='tomato'; ctx.ellipse(cx,cy,tile*0.38,tile*0.32,0,0,Math.PI*2); ctx.fill();
        // 亮斑
        ctx.beginPath(); ctx.fillStyle='rgba(255,255,255,0.18)'; ctx.ellipse(cx - tile*0.12, cy - tile*0.12, tile*0.08, tile*0.06, 0,0,Math.PI*2); ctx.fill();
        // 叶子
        ctx.save(); ctx.translate(cx + tile*0.22, cy - tile*0.28); ctx.rotate(-0.6); ctx.fillStyle='rgba(40,160,40,0.95)'; ctx.beginPath(); ctx.ellipse(0,0,tile*0.18,tile*0.08,0,0,Math.PI*2); ctx.fill(); ctx.restore();
      }

      // 画蛇
      snakes.forEach((s,si)=>{
        for(let i=0;i<s.body.length;i++){
          const b = s.body[i];
          const px = b.x*tile, py = b.y*tile;
          // 头部加亮
          if(i===s.body.length-1){
            ctx.fillStyle = s.color; ctx.fillRect(px+1,py+1,tile-2,tile-2);
            // 亮边
            ctx.strokeStyle='rgba(255,255,255,0.08)'; ctx.strokeRect(px+1,py+1,tile-2,tile-2);
            // 眼睛（方向感）
            ctx.fillStyle='rgba(0,0,0,0.6)';
            const hx = px + (s.dir==='left'? tile*0.18 : s.dir==='right'? tile*0.62 : tile*0.32);
            const hy1 = py + (s.dir==='up'? tile*0.18 : tile*0.32);
            const hy2 = py + (s.dir==='down'? tile*0.62 : tile*0.62);
            ctx.fillRect(hx, hy1, Math.max(1, Math.floor(tile*0.08)), Math.max(1, Math.floor(tile*0.08)));
          } else {
            // 身体采用半透明
            ctx.fillStyle = hexToRgba(s.color, 0.78); ctx.fillRect(px+1,py+1,tile-2,tile-2);
          }
        }
      })
    }

    // 工具：hex -> rgba
    function hexToRgba(hex, a=1){
      const h = hex.replace('#',''); const bigint = parseInt(h,16); const r=(bigint>>16)&255; const g=(bigint>>8)&255; const b=bigint&255; return `rgba(${r},${g},${b},${a})`;
    }

    // 绑定菜单按钮
    document.getElementById('singleBtn').addEventListener('click', ()=>{ menu.style.display='none'; gameWrap.style.display='flex'; resizeCanvas(); initGame(State.SINGLE)});
    document.getElementById('twoBtn').addEventListener('click', ()=>{ menu.style.display='none'; gameWrap.style.display='flex'; resizeCanvas(); initGame(State.TWO)});
    document.getElementById('aiBtn').addEventListener('click', ()=>{ menu.style.display='none'; gameWrap.style.display='flex'; resizeCanvas(); initGame(State.AI)});
    document.getElementById('mobileBtn').addEventListener('click', ()=>{ menu.style.display='none'; gameWrap.style.display='flex'; resizeCanvas(); initGame(State.MOBILE)});
    document.getElementById('practiceBtn').addEventListener('click', ()=>{ menu.style.display='none'; gameWrap.style.display='flex'; resizeCanvas(); initGame(State.PRACTICE)});

    // 页面可见性处理：切换标签页时暂停
    document.addEventListener('visibilitychange', ()=>{ if(document.hidden){ stopLoop() } else { if(!paused) startLoop() } });

    // 初始渲染
    requestAnimationFrame(render);

  </script>

  <!-- 注：把此文件命名为 index.html，上传到 GitHub 仓库的根目录，开启 GitHub Pages（Settings -> Pages -> branch: main / folder: /）。页面会自动发布为静态站点。 -->
</body>
</html>
