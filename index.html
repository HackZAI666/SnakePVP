<!doctype html>
<html lang="zh-CN">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>贪吃蛇大作战 风格 — HackZ 出品 (更新：修复抽搐、7x 变大缓慢、AI 更强)</title>
<style>
  :root{--bg:#ffffff;--panel:rgba(0,0,0,0.6);--accent:#2e8ef7}
  html,body{height:100%;margin:0;font-family:system-ui,Segoe UI,Roboto,"Helvetica Neue",Arial;background:var(--bg);color:#222;overflow:hidden}
  #canvas{display:block;background:var(--bg)}
  #splash{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;flex-direction:column;background:linear-gradient(180deg,#ffffff,#f6f7fb);z-index:60;transition:opacity .9s ease}
  #splash.hidden{opacity:0;pointer-events:none}
  .splash-logo{font-weight:900;font-size:64px;letter-spacing:8px;color:#111}
  #lobby{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;flex-direction:column;gap:16px;background:transparent;z-index:50}
  .logo{font-weight:900;font-size:48px;letter-spacing:6px;color:#111}
  .subtitle{color:#555;font-size:14px}
  .menu{display:flex;gap:10px;align-items:center}
  .btn{padding:12px 18px;border-radius:8px;border:0;background:var(--accent);color:white;font-weight:600;cursor:pointer;font-size:16px}
  .btn.secondary{background:transparent;border:1px solid rgba(0,0,0,0.08);color:#222}
  #leaderboard{position:fixed;right:12px;top:12px;background:var(--panel);color:#fff;padding:10px;border-radius:8px;min-width:160px;z-index:20;font-size:13px}
  #hud{position:fixed;left:12px;bottom:12px;background:var(--panel);color:#fff;padding:8px;border-radius:8px;z-index:20;font-size:13px}
  #notice{position:fixed;left:50%;transform:translateX(-50%);top:14px;background:rgba(0,0,0,0.55);color:#fff;padding:8px 12px;border-radius:999px;font-size:13px;z-index:25}
  #debugErr{position:fixed;right:12px;bottom:12px;background:rgba(255,0,0,0.85);color:#fff;padding:8px;border-radius:6px;font-size:12px;display:none;z-index:100}
</style>
</head>
<body>

<div id="splash" aria-hidden="false">
  <div class="splash-logo">HackZ 出品</div>
  <div style="margin-top:8px;color:#666">贪吃蛇大作战 风格 — 本地 Demo</div>
</div>

<div id="lobby" aria-hidden="true">
  <div class="logo">HackZ 出品</div>
  <div class="subtitle">WASD 控制 · O 复活 · 吃球变长 · 30 AI（更聪明）</div>
  <div class="menu">
    <button id="startBtn" class="btn">开始游戏</button>
    <button id="skinsBtn" class="btn secondary">选择皮肤（占位）</button>
    <button id="shopBtn" class="btn secondary">商城（占位）</button>
  </div>
  <div style="font-size:13px;color:#444">提示：被击杀会掉出许多小球（按死亡轨迹），吃到 +1 段；视觉变大速度已降低为原来的 1/7。</div>
</div>

<canvas id="canvas"></canvas>
<div id="leaderboard" style="display:none"></div>
<div id="hud" style="display:none"></div>
<div id="notice" style="display:none"></div>
<div id="debugErr"></div>

<script>
/* 重要：此次改动基于你反馈的三个重点：
   1) 修复“敌人击杀后头部抽搐”：在增长前同步 prevHead、把新增段初始化在尾部、并保持平滑插值
   2) 视觉变大速度变慢：实现“以 segmentCount/7 作为半径输入”，视感增长变慢 7 倍
   3) AI 更强：改进行为，增加绕圈/拉扯/突进（burst）逻辑，同时确保霸屏型 AI 仍少量存在
*/

// 基本参数（可按需再调）
const MAP_HALF = 4200;
const BORDER_PADDING = 80;
const GRID_SIZE = 90;

// 视觉缩放：将 segmentCount / GROW_SCALE_FACTOR 传入到 scale 计算，达到“变大慢 7 倍”的效果
const GROW_SCALE_FACTOR = 7; // <= 说明：视觉以 segmentCount/7 为依据

const BASE_RADIUS = 10;
const SCALE_MAX = 3.0;
const SCALE_FROM = 10;
const SCALE_TO = 130;

const NUM_AI = 30;
const RESPAWN_MS = 10000;
const PELLET_RADIUS = 6;
const PELLET_TTL = 60 * 1000;

const SPAWN_GRACE_MS = 420; // spawn protection

// debug UI
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
let W = window.innerWidth, H = window.innerHeight;
canvas.width = W; canvas.height = H;

const splash = document.getElementById('splash');
const lobby = document.getElementById('lobby');
const startBtn = document.getElementById('startBtn');
const leaderboardEl = document.getElementById('leaderboard');
const hud = document.getElementById('hud');
const notice = document.getElementById('notice');
const debugErr = document.getElementById('debugErr');

let camX = 0, camY = 0;
const keys = { w:false,a:false,s:false,d:false,ArrowUp:false,ArrowLeft:false,ArrowDown:false,ArrowRight:false };
window.addEventListener('keydown', e=>{
  if(e.code==='KeyW') keys.w = true;
  if(e.code==='KeyA') keys.a = true;
  if(e.code==='KeyS') keys.s = true;
  if(e.code==='KeyD') keys.d = true;
  if(e.code==='ArrowUp') keys.ArrowUp = true;
  if(e.code==='ArrowLeft') keys.ArrowLeft = true;
  if(e.code==='ArrowDown') keys.ArrowDown = true;
  if(e.code==='ArrowRight') keys.ArrowRight = true;
});
window.addEventListener('keyup', e=>{
  if(e.code==='KeyW') keys.w = false;
  if(e.code==='KeyA') keys.a = false;
  if(e.code==='KeyS') keys.s = false;
  if(e.code==='KeyD') keys.d = false;
  if(e.code==='ArrowUp') keys.ArrowUp = false;
  if(e.code==='ArrowLeft') keys.ArrowLeft = false;
  if(e.code==='ArrowDown') keys.ArrowDown = false;
  if(e.code==='ArrowRight') keys.ArrowRight = false;
});

// utils
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
function randomColor(){ return `hsl(${Math.floor(Math.random()*360)},68%,55%)`; }

// Snake class
class Snake {
  constructor(id,x,y,color,isAI=false){
    this.id = id;
    this.head = { x:x, y:y, angle: Math.random()*Math.PI*2 };
    this.prevHead = { x:x, y:y };
    this.color = color || randomColor();
    this.isAI = isAI;
    this.alive = true;
    this.segs = [];
    this.spawnTime = Date.now();
    // new size distribution: most small, fewer medium, tiny fraction giant
    if(!isAI){
      this.segmentCount = 18 + Math.floor(Math.random()*12);
    } else {
      const r = Math.random();
      if(r < 0.66) this.segmentCount = 8 + Math.floor(Math.random()*26);       // small
      else if(r < 0.92) this.segmentCount = 28 + Math.floor(Math.random()*48);  // medium
      else this.segmentCount = 120 + Math.floor(Math.random()*200);             // giant (very rare)
    }
    this.speedBase = 4.2 + Math.random()*0.8;
    if(this.segmentCount > 120) this.speedBase = Math.max(1.0, this.speedBase - 2.0);
    this.score = 0;
    this.type = chooseAIType();
    this.respawnAt = 0;
    this.burstUntil = 0; // for temporary burst speed to implement "拉扯/突进"
    for(let i=0;i<this.segmentCount;i++) this.segs.push({x:this.head.x,y:this.head.y});
  }
  // effective value used for visual scaling is segmentCount / GROW_SCALE_FACTOR
  effectiveCount(){ return Math.max(0, this.segmentCount / GROW_SCALE_FACTOR); }
  scale(){
    const eff = this.effectiveCount();
    const t = clamp((eff - SCALE_FROM) / (SCALE_TO - SCALE_FROM), 0, 1);
    return 1 + t * (SCALE_MAX - 1);
  }
  radius(){ return BASE_RADIUS * this.scale(); }
  segSpacing(){ return this.radius() * 0.82; }
  currentSpeed(){
    // more pronounced slowdown: larger => slower; also honor burst
    const k = 0.035;
    let s = Math.max(0.25, this.speedBase - (this.segmentCount * k));
    if(this.burstUntil && Date.now() < this.burstUntil) s *= 1.35; // burst multiplier
    return s;
  }
  grow(n){
    // FIX: before changing segments length, lock prevHead to avoid twitch
    this.prevHead.x = this.head.x; this.prevHead.y = this.head.y;
    // add at tail to avoid head interpolation issues
    for(let i=0;i<n;i++){
      const tail = this.segs[this.segs.length-1] || {x:this.head.x,y:this.head.y};
      this.segs.push({ x: tail.x, y: tail.y });
      this.segmentCount++;
    }
  }
  shrinkToSmall(){
    this.segmentCount = 10 + Math.floor(Math.random()*10);
    this.segs.length = Math.min(this.segs.length, this.segmentCount);
    while(this.segs.length < this.segmentCount){
      const tail = this.segs[this.segs.length-1] || {x:this.head.x,y:this.head.y};
      this.segs.push({ x: tail.x, y: tail.y });
    }
    this.speedBase = 4.2 + Math.random()*0.8;
  }
}

// pellets
let pellets = []; // {x,y,color,created}

// globals
let snakes = [];
let playerSnake = null;

// AI helpers
function chooseAIType(){
  const r = Math.random();
  if(r < 0.18) return 'aggressive';
  if(r < 0.36) return 'pvper';
  if(r < 0.6) return 'hunter';
  if(r < 0.9) return 'wanderer';
  return 'coward';
}
function findNearestEnemy(s, range=1200){
  let best=null, bestd=Infinity;
  for(const other of snakes){
    if(other===s || !other.alive) continue;
    const dx = other.head.x - s.head.x, dy = other.head.y - s.head.y;
    const d = Math.hypot(dx,dy);
    if(d < bestd && d <= range){ best = other; bestd = d; }
  }
  return best;
}

// AI behaviour (stronger, with burst & circle)
function aiThink(s){
  if(!s.alive) return;
  const typ = s.type;

  // small random jitter less often
  if(Math.random() < 0.003) s.head.angle += (Math.random()-0.5)*0.9;

  const now = Date.now();

  if(typ === 'aggressive'){
    // prefer player as main target
    const dx = playerSnake.head.x - s.head.x, dy = playerSnake.head.y - s.head.y;
    const d = Math.hypot(dx,dy);
    if(d < 1400){
      // if s is larger, try to circle then burst; if smaller, approach carefully
      const targetAng = Math.atan2(dy,dx);
      if(s.segmentCount > playerSnake.segmentCount + 18){
        // circle: offset angle by small oscillation to create "绕圈拉扯"
        const oscill = Math.sin(now / 300 + (s.segmentCount % 10)) * 0.9;
        s.head.angle = lerpAngle(s.head.angle, targetAng + oscill, 0.16);
        // occasionally burst forward
        if(Math.random() < 0.02) s.burstUntil = now + 450 + Math.random()*350;
      } else {
        // if smaller, be more cautious but still chase
        s.head.angle = lerpAngle(s.head.angle, targetAng, 0.14);
        if(Math.random() < 0.01) s.burstUntil = now + 280;
      }
    } else {
      s.head.angle += (Math.random()-0.5)*0.02;
    }
  } else if(typ === 'pvper'){
    const near = findNearestEnemy(s, 1100);
    if(near){
      const dx = near.head.x - s.head.x, dy = near.head.y - s.head.y;
      const d = Math.hypot(dx,dy);
      const targ = Math.atan2(dy,dx);
      // if near and s roughly similar to target, try to circle for angle advantage
      if(d < 520 && Math.abs(s.segmentCount - near.segmentCount) < 30){
        const offset = (Math.random() < 0.5 ? 0.6 : -0.6);
        s.head.angle = lerpAngle(s.head.angle, targ + offset, 0.18);
        if(Math.random() < 0.12) s.burstUntil = now + 300;
      } else {
        s.head.angle = lerpAngle(s.head.angle, targ, 0.12 + Math.random()*0.06);
        if(d < 350 && s.segmentCount > near.segmentCount + 6) s.burstUntil = now + 380;
      }
    } else s.head.angle += (Math.random()-0.5)*0.02;
  } else if(typ === 'hunter'){
    // hunt smaller prey
    let target = null, td = Infinity;
    for(const o of snakes){ if(o===s || !o.alive) continue; if(o.segmentCount < s.segmentCount - 6){ const dx = o.head.x - s.head.x, dy=o.head.y-s.head.y; const d=Math.hypot(dx,dy); if(d < td && d < 900){ td=d; target=o; } } }
    if(target){
      s.head.angle = lerpAngle(s.head.angle, Math.atan2(target.head.y - s.head.y, target.head.x - s.head.x), 0.12);
      if(td < 420) s.burstUntil = now + 200;
    } else s.head.angle += (Math.random()-0.5)*0.02;
  } else if(typ === 'wanderer'){
    s.head.angle += (Math.random()-0.5)*0.01;
    const margin = MAP_HALF - 300;
    if(Math.abs(s.head.x) > margin || Math.abs(s.head.y) > margin) s.head.angle = lerpAngle(s.head.angle, Math.atan2(-s.head.y, -s.head.x), 0.14);
  } else if(typ === 'coward'){
    let big=null, bd=Infinity;
    for(const o of snakes){ if(o===s || !o.alive) continue; if(o.segmentCount > s.segmentCount + 20){ const dx=o.head.x-s.head.x, dy=o.head.y-s.head.y; const d=Math.hypot(dx,dy); if(d<bd){bd=d;big=o;} } }
    if(big && bd < 700) s.head.angle = lerpAngle(s.head.angle, Math.atan2(s.head.y - big.head.y, s.head.x - big.head.x), 0.22);
    else s.head.angle += (Math.random()-0.5)*0.03;
  }
}
function lerpAngle(a,b,t){ let diff=b-a; while(diff>Math.PI) diff-=Math.PI*2; while(diff<-Math.PI) diff+=Math.PI*2; return a+diff*t; }

// point<->segment distance helper
function pointToSegmentDistance(ax,ay,bx,by,cx,cy){
  const vx = bx-ax, vy = by-ay;
  const wx = cx-ax, wy = cy-ay;
  const l2 = vx*vx + vy*vy;
  let t = 0;
  if(l2 > 0) t = (vx*wx + vy*wy) / l2;
  t = Math.max(0, Math.min(1, t));
  const projx = ax + t * vx, projy = ay + t * vy;
  const dx = cx - projx, dy = cy - projy;
  return Math.hypot(dx,dy);
}

// update movement (store prevHead)
function updateSnakeMovement(s, dt){
  if(!s.alive) return;
  s.prevHead.x = s.head.x; s.prevHead.y = s.head.y;
  if(!s.isAI){
    let vx=0, vy=0;
    if(keys.w || keys.ArrowUp) vy -= 1;
    if(keys.s || keys.ArrowDown) vy += 1;
    if(keys.a || keys.ArrowLeft) vx -= 1;
    if(keys.d || keys.ArrowRight) vx += 1;
    if(vx!==0 || vy!==0) s.head.angle = Math.atan2(vy, vx);
  } else aiThink(s);

  const speed = s.currentSpeed();
  s.head.x += Math.cos(s.head.angle) * speed * dt;
  s.head.y += Math.sin(s.head.angle) * speed * dt;

  const maxCoord = MAP_HALF - BORDER_PADDING;
  s.head.x = Math.max(-maxCoord, Math.min(maxCoord, s.head.x));
  s.head.y = Math.max(-maxCoord, Math.min(maxCoord, s.head.y));

  if(!Array.isArray(s.segs)) s.segs = [];
  if(s.segs.length === 0) s.segs.push({ x:s.head.x, y:s.head.y });
  s.segs[0] = { x: s.head.x, y: s.head.y };
  while(s.segs.length < s.segmentCount) s.segs.push({ x: s.head.x, y: s.head.y });
  if(s.segs.length > s.segmentCount) s.segs.length = s.segmentCount;

  const target = s.segSpacing();
  for(let i=1;i<s.segs.length;i++){
    const prev = s.segs[i-1], cur = s.segs[i];
    const dx = prev.x - cur.x, dy = prev.y - cur.y;
    const dist = Math.hypot(dx,dy) || 0.0001;
    const nx = prev.x - (dx/dist)*target;
    const ny = prev.y - (dy/dist)*target;
    cur.x = cur.x + (nx - cur.x) * 0.92;
    cur.y = cur.y + (ny - cur.y) * 0.92;
  }
}

// pellets pickup & cleanup
function updatePelletPickup(){
  if(pellets.length===0) return;
  for(let pi = pellets.length-1; pi>=0; pi--){
    const p = pellets[pi];
    for(const s of snakes){
      if(!s.alive) continue;
      const rad = s.radius();
      const dx = s.head.x - p.x, dy = s.head.y - p.y;
      const d = Math.hypot(dx,dy);
      if(d < rad + PELLET_RADIUS*0.8){
        // each pellet gives +1 segment (but visual scale is slowed by GROW_SCALE_FACTOR)
        s.grow(1);
        pellets.splice(pi,1);
        break;
      }
    }
  }
  const now = Date.now();
  for(let i=pellets.length-1;i>=0;i--) if(now - pellets[i].created > PELLET_TTL) pellets.splice(i,1);
}

// create pellets from victim's segments (trajectory)
function createPelletsFromVictim(victim){
  const positions = (victim.segs && victim.segs.slice(0, victim.segmentCount)) || [];
  const MAX_PELLETS = 300;
  let toUse = positions;
  if(positions.length > MAX_PELLETS){
    toUse = [];
    const step = positions.length / MAX_PELLETS;
    for(let i=0;i<MAX_PELLETS;i++){
      const idx = Math.floor(i * step);
      toUse.push(positions[idx]);
    }
  }
  for(const pos of toUse) pellets.push({ x: pos.x, y: pos.y, color: victim.color, created: Date.now() });
}

// kill logic (with spawn-protection & prevent twitch)
function killSnake(victim, killer, reason){
  if(!victim.alive) return;
  // spawn protection to avoid immediate double-kill
  if(Date.now() - (victim.spawnTime || 0) < SPAWN_GRACE_MS) return;
  victim.alive = false;
  victim.respawnAt = Date.now() + RESPAWN_MS;
  createPelletsFromVictim(victim);

  if(killer && killer.alive){
    // smaller gain than before (balance): original ~4-10, we shrink slightly to reduce explosion growth
    const rawGain = 4 + Math.floor(Math.random()*6);
    const gain = Math.max(1, Math.floor(rawGain / 2)); // moderate reduction
    // FIX: prevent head twitch by copying prevHead then grow
    killer.prevHead.x = killer.head.x; killer.prevHead.y = killer.head.y;
    killer.grow(gain);
    killer.score = (killer.score || 0) + 1;
    showNotice(`${killer === playerSnake ? '你' : killer.id} 击杀 ${victim === playerSnake ? '你' : victim.id} +${gain}`);
  } else {
    showNotice(`${victim === playerSnake ? '你' : victim.id} 因 ${reason || '原因'} 死亡`);
  }
}

// collisions with continuous detection & dynamic radii
function checkCollisions(){
  const b = MAP_HALF - BORDER_PADDING;
  for(const s of snakes){
    if(!s.alive) continue;
    if(Math.abs(s.head.x) > b || Math.abs(s.head.y) > b){
      killSnake(s, null, '边界');
    }
  }

  for(let i=0;i<snakes.length;i++){
    const A = snakes[i];
    if(!A.alive) continue;
    const ax0 = (A.prevHead && A.prevHead.x) || A.head.x;
    const ay0 = (A.prevHead && A.prevHead.y) || A.head.y;
    const ax1 = A.head.x, ay1 = A.head.y;
    const radA = A.radius();
    for(let j=0;j<snakes.length;j++){
      if(i===j) continue;
      const B = snakes[j];
      if(!B.alive) continue;
      const radB = B.radius();

      // head-head
      if(i < j){
        const dxHH = A.head.x - B.head.x, dyHH = A.head.y - B.head.y;
        const dHH = Math.hypot(dxHH,dyHH);
        if(dHH < (radA + radB) * 0.9){
          const dist = Math.max(0.0001, dHH);
          const nx = (B.head.x - A.head.x)/dist, ny = (B.head.y - A.head.y)/dist;
          const vAx = Math.cos(A.head.angle) * A.currentSpeed();
          const vAy = Math.sin(A.head.angle) * A.currentSpeed();
          const vBx = Math.cos(B.head.angle) * B.currentSpeed();
          const vBy = Math.sin(B.head.angle) * B.currentSpeed();
          const projA = vAx * nx + vAy * ny;
          const projB = -(vBx * nx + vBy * ny);
          const EPS = 0.14;
          if(projA > projB + EPS){ killSnake(B, A, '头碰头'); }
          else if(projB > projA + EPS){ killSnake(A, B, '头碰头'); }
          else { if(Math.random() < 0.5) killSnake(A, B, '头碰头(随机)'); else killSnake(B, A, '头碰头(随机)'); }
          continue;
        }
      }

      // head A path vs body of B (continuous)
      const skip = 4;
      for(let k=skip;k<B.segs.length;k++){
        const seg = B.segs[k];
        const dseg = pointToSegmentDistance(ax0,ay0,ax1,ay1, seg.x, seg.y);
        const threshold = Math.max(4, (radA + radB) * 0.55);
        // ignore collisions with newly spawned victims
        if(dseg < threshold && !(Date.now() - (B.spawnTime || 0) < SPAWN_GRACE_MS)){
          killSnake(A, B, '穿透/撞到身体');
          break;
        }
      }
      if(!A.alive) break;
    }
  }
}

// respawn handling
function handleRespawns(){
  const now = Date.now();
  for(const s of snakes){
    if(!s.alive && s.respawnAt && now >= s.respawnAt){
      s.alive = true;
      s.head.x = (Math.random()*2-1) * (MAP_HALF - 800);
      s.head.y = (Math.random()*2-1) * (MAP_HALF - 800);
      s.head.angle = Math.random()*Math.PI*2;
      s.segs = [];
      s.shrinkToSmall();
      for(let i=0;i<s.segmentCount;i++) s.segs.push({x:s.head.x,y:s.head.y});
      s.respawnAt = 0;
      s.spawnTime = Date.now();
      s.score = 0;
      showNotice(`${s === playerSnake ? '你' : s.id} 已复活`);
    }
  }
}

// drawing & UI helpers
function worldToScreen(wx, wy){ return { x: Math.round((wx - camX) + W/2), y: Math.round((wy - camY) + H/2) }; }
function colorWithAlpha(hsl,a){ return hsl.replace('hsl(', 'hsla(').replace(')', `,${a})`); }
let noticeTimer = 0;
function showNotice(txt){ notice.innerText = txt; notice.style.display = 'block'; noticeTimer = Date.now() + 1600; }

// draw functions
function drawMap(){
  ctx.fillStyle = '#fff'; ctx.fillRect(0,0,W,H);
  ctx.strokeStyle = '#e6e6e6'; ctx.lineWidth = 1;
  const left = camX - W/2 - GRID_SIZE, top = camY - H/2 - GRID_SIZE;
  const right = camX + W/2 + GRID_SIZE, bottom = camY + H/2 + GRID_SIZE;
  const startX = Math.floor(left / GRID_SIZE) * GRID_SIZE, startY = Math.floor(top / GRID_SIZE) * GRID_SIZE;
  ctx.beginPath();
  for(let gx = startX; gx <= right; gx += GRID_SIZE){
    const s = worldToScreen(gx, camY); ctx.moveTo(s.x, 0); ctx.lineTo(s.x, H);
  }
  for(let gy = startY; gy <= bottom; gy += GRID_SIZE){
    const s = worldToScreen(camX, gy); ctx.moveTo(0, s.y); ctx.lineTo(W, s.y);
  }
  ctx.stroke();
  const leftWorld = -MAP_HALF + BORDER_PADDING, topWorld = -MAP_HALF + BORDER_PADDING;
  const rightWorld = MAP_HALF - BORDER_PADDING, bottomWorld = MAP_HALF - BORDER_PADDING;
  const p1 = worldToScreen(leftWorld, topWorld), p2 = worldToScreen(rightWorld, bottomWorld);
  ctx.strokeStyle = 'rgba(255,60,60,0.98)'; ctx.lineWidth = 6; ctx.strokeRect(p1.x, p1.y, p2.x - p1.x, p2.y - p1.y);
}
function drawPellets(){
  for(const p of pellets){
    const pos = worldToScreen(p.x, p.y);
    ctx.beginPath(); ctx.fillStyle = p.color; ctx.arc(pos.x, pos.y, PELLET_RADIUS, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.fillStyle = 'rgba(255,255,255,0.6)'; ctx.arc(pos.x - 2, pos.y - 2, Math.max(1, PELLET_RADIUS*0.28), 0, Math.PI*2); ctx.fill();
  }
}
function drawSnakes(){
  for(const s of snakes){
    if(!s.alive) continue;
    const rad = s.radius();
    for(let i = s.segs.length - 1; i >= 0; i--){
      const seg = s.segs[i];
      const pos = worldToScreen(seg.x, seg.y);
      const alpha = 0.95 - (i / s.segs.length) * 0.5;
      ctx.fillStyle = colorWithAlpha(s.color, alpha); ctx.beginPath(); ctx.arc(pos.x, pos.y, rad, 0, Math.PI*2); ctx.fill();
    }
    const headPos = worldToScreen(s.head.x, s.head.y);
    ctx.beginPath(); ctx.fillStyle = '#fff'; ctx.arc(headPos.x, headPos.y, rad * 0.36, 0, Math.PI*2); ctx.fill();
    const eyeOffset = rad * 0.46;
    const ex = headPos.x + Math.cos(s.head.angle) * eyeOffset, ey = headPos.y + Math.sin(s.head.angle) * eyeOffset;
    ctx.beginPath(); ctx.fillStyle = 'rgba(0,0,0,0.6)'; ctx.arc(ex, ey, Math.max(2, rad*0.18), 0, Math.PI*2); ctx.fill();
    ctx.font = '12px sans-serif'; ctx.fillStyle = '#111'; ctx.textAlign = 'center';
    ctx.fillText(Math.floor(s.segmentCount), headPos.x, headPos.y - rad - 8);
    if(s === playerSnake) hud.innerHTML = `段数: <b>${Math.floor(s.segmentCount)}</b> &nbsp; 半径: <b>${Math.round(rad)}</b> &nbsp; 速度: <b>${s.currentSpeed().toFixed(2)}</b>`;
  }
}
function updateLeaderboard(){
  const arr = snakes.slice().filter(s=>s.alive).sort((a,b)=>b.segmentCount - a.segmentCount);
  let html = '<b>排行榜 Top 5</b><br>';
  for(let i=0;i<5;i++){ const s = arr[i]; if(!s) break; const name = s === playerSnake ? '你' : s.id; html += `${i+1}. ${name} — ${Math.floor(s.segmentCount)}<br>`; }
  leaderboardEl.innerHTML = html;
}

// main loop with try/catch
let lastTime = performance.now(), running = false;
function mainLoop(now){
  if(!running) return;
  try {
    const dtRaw = now - lastTime; lastTime = now;
    const dt = Math.min(2.0, dtRaw / 16.666);

    for(const s of snakes){ if(s.alive) updateSnakeMovement(s, dt); }
    checkCollisions();
    updatePelletPickup();
    handleRespawns();

    camX += (playerSnake.head.x - camX) * 0.14;
    camY += (playerSnake.head.y - camY) * 0.14;

    drawMap(); drawPellets(); drawSnakes(); updateLeaderboard();

    if(noticeTimer && Date.now() > noticeTimer){ notice.style.display = 'none'; noticeTimer = 0; }
    debugErr.style.display = 'none';
  } catch (err){
    console.error('主循环出错：', err);
    debugErr.style.display = 'block';
    debugErr.innerText = '发生错误（控制台可见），继续运行…';
  }
  requestAnimationFrame(mainLoop);
}

// init/start/resume
function initGame(){
  snakes = []; pellets = [];
  playerSnake = new Snake('你', 0, 0, '#2e8ef7', false);
  snakes.push(playerSnake);
  for(let i=0;i<NUM_AI;i++){
    const x = (Math.random()*2-1) * (MAP_HALF - 500);
    const y = (Math.random()*2-1) * (MAP_HALF - 500);
    const s = new Snake('AI'+(i+1), x, y, randomColor(), true);
    snakes.push(s);
  }
  leaderboardEl.style.display = 'block'; hud.style.display = 'block'; notice.style.display = 'none';
  camX = playerSnake.head.x; camY = playerSnake.head.y;
  showNotice('游戏准备就绪，开始吧！');
}

function showSplashThenLobby(){ splash.style.display = 'flex'; lobby.style.display = 'none'; setTimeout(()=>{ splash.classList.add('hidden'); setTimeout(()=>{ splash.style.display='none'; lobby.style.display='flex'; }, 900); }, 1400); }

startBtn.addEventListener('click', ()=>{
  lobby.style.display = 'none';
  canvas.style.display = 'block';
  canvas.width = window.innerWidth; canvas.height = window.innerHeight;
  W = canvas.width; H = canvas.height;
  initGame();
  running = true; lastTime = performance.now();
  requestAnimationFrame(mainLoop);
});
window.addEventListener('resize', ()=>{ canvas.width = window.innerWidth; canvas.height = window.innerHeight; W = canvas.width; H = canvas.height; });
window.addEventListener('keydown', e=>{ if(e.key==='o' || e.key==='O'){ if(playerSnake && !playerSnake.alive){ playerSnake.respawnAt = Date.now(); playerSnake.spawnTime = Date.now(); } } });
// quick respawn debug: R also allowed
window.addEventListener('keydown', e=>{ if(e.key==='r' || e.key==='R'){ if(playerSnake && !playerSnake.alive){ playerSnake.respawnAt = Date.now(); playerSnake.spawnTime = Date.now(); } } });

canvas.width = W; canvas.height = H;
leaderboardEl.style.display = 'none'; hud.style.display = 'none';
showSplashThenLobby();
</script>

</body>
</html>






